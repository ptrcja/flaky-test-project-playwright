# GitHub Actions Workflow for Flaky Test Detection
#
# This workflow automatically runs flaky detection on:
# - Nightly schedule
# - Pull requests
# - Manual trigger
#
# Learning Goals:
# - Understand CI/CD pipelines
# - Learn GitHub Actions syntax
# - Practice automation strategies
# - Implement PR feedback mechanisms

name: Flaky Test Detection with CTRF

# TODO #1: Define workflow triggers
#
# The 'on' section defines when this workflow runs.
# You need to implement three triggers:
#
# 1. schedule:
#    - Use cron syntax: '0 2 * * *' (2 AM daily)
#    - Format: minute hour day month day-of-week
#    - Tools like crontab.guru help build cron expressions
#
# 2. workflow_dispatch:
#    - Allows manual triggering from GitHub UI
#    - Add 'inputs' with a 'runs' parameter
#    - Type: choice with options 5, 10, 15, 20, 30
#    - Default: '10'
#
# 3. pull_request:
#    - Trigger on PRs to main/develop branches
#    - Only when test files change (use 'paths' filter)
#    - Watch: src/tests/**, playwright.config.ts, package.json
on:
  # Nightly runs for continuous monitoring
  schedule:
    - cron: '0 2 * * *'

  # Manual trigger with parameters
  workflow_dispatch:
    inputs:
      runs:
        description: 'Number of test runs'
        required: false
        default: '10'
        type: choice
        options:
          - '5'
          - '10'
          - '15'
          - '20'
          - '30'

  # Run on pull requests
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'src/tests/**'
      - 'playwright.config.ts'
      - 'package.json'

jobs:
  # TODO #2: Define the main job
  #
  # Job name: detect-flaky-tests
  # Runner: ubuntu-latest (GitHub-hosted Linux runner)
  # Timeout: 60 minutes (tests can take time)
  detect-flaky-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
    # TODO #3: Implement checkout step
    #
    # Purpose: Clone the repository code
    # Action: actions/checkout@v4
    #
    # Why v4? Latest stable version with improved performance
    # Name: Use emoji ðŸ“¥ for visual clarity
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4

    # TODO #4: Implement Node.js setup
    #
    # Purpose: Install Node.js and npm
    # Action: actions/setup-node@v4
    #
    # Configuration:
    # - node-version: '20' (LTS version)
    # - cache: 'npm' (speeds up dependency installation)
    #
    # The cache option reuses node_modules between runs
    - name: ðŸ”§ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    # TODO #5: Implement dependency installation
    #
    # Purpose: Install npm packages and Playwright browsers
    #
    # Commands to run:
    # 1. npm ci (faster than npm install for CI)
    # 2. npx playwright install --with-deps chromium
    #
    # Why npm ci?
    # - Installs from package-lock.json
    # - Faster and more reliable for CI
    # - Fails if lock file is outdated
    - name: ðŸ“¦ Install dependencies
      run: |
        npm ci
        npx playwright install --with-deps chromium

    # TODO #6: Implement flaky detection execution
    #
    # Purpose: Run the main detection script
    #
    # Key points:
    # - id: detection (allows referencing in other steps)
    # - continue-on-error: true (process results even if tests fail)
    # - Use github.event.inputs.runs for manual trigger
    # - Default to '10' if not manually triggered
    #
    # Command: npm run detect-flaky -- <number_of_runs>
    #
    # The ${{ }} syntax is GitHub Actions expression syntax
    - name: ðŸ” Run flaky detection
      id: detection
      run: |
        npm run detect-flaky -- ${{ github.event.inputs.runs || '10' }}
      continue-on-error: true

    # TODO #7: Implement results parsing
    #
    # Purpose: Extract metrics from JSON report
    #
    # Implementation details:
    # - if: always() (run even if previous steps failed)
    # - id: parse (for referencing outputs)
    # - Use jq tool to parse JSON (pre-installed on runners)
    # - Set outputs using >> $GITHUB_OUTPUT
    #
    # Outputs to set:
    # - flaky_count: Number of flaky tests
    # - total_count: Total number of tests
    # - health_score: Overall health score
    # - status_emoji: âœ… or ðŸ”´ based on results
    #
    # Example jq usage:
    # jq '.summary.flakyTests' reports/analysis/flaky-report.json
    - name: ðŸ“Š Parse results
      id: parse
      if: always()
      run: |
        # Extract summary from JSON report
        if [ -f "reports/analysis/flaky-report.json" ]; then
          FLAKY_COUNT=$(jq '.summary.flakyTests' reports/analysis/flaky-report.json)
          TOTAL_COUNT=$(jq '.summary.totalTests' reports/analysis/flaky-report.json)
          HEALTH_SCORE=$(jq '.summary.healthScore' reports/analysis/flaky-report.json)

          echo "flaky_count=$FLAKY_COUNT" >> $GITHUB_OUTPUT
          echo "total_count=$TOTAL_COUNT" >> $GITHUB_OUTPUT
          echo "health_score=$HEALTH_SCORE" >> $GITHUB_OUTPUT

          # Set status emoji
          if [ "$FLAKY_COUNT" -eq 0 ]; then
            echo "status_emoji=âœ…" >> $GITHUB_OUTPUT
          else
            echo "status_emoji=ðŸ”´" >> $GITHUB_OUTPUT
          fi
        fi

    # TODO #8: Implement artifact upload for CTRF reports
    #
    # Purpose: Save CTRF JSON reports for debugging
    # Action: actions/upload-artifact@v4
    #
    # Configuration:
    # - name: ctrf-reports-${{ github.run_number }}
    # - path: reports/ctrf/
    # - retention-days: 30
    #
    # Why upload artifacts?
    # - Debug test failures
    # - Historical analysis
    # - Share results with team
    - name: ðŸ“¤ Upload CTRF reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ctrf-reports-${{ github.run_number }}
        path: reports/ctrf/
        retention-days: 30

    # TODO #9: Implement artifact upload for analysis reports
    #
    # Similar to #8 but for:
    # - path: reports/analysis/
    # - Contains HTML, MD, JSON, CSV reports
    # - These are the main output files
    - name: ðŸ“¤ Upload analysis reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: flaky-analysis-${{ github.run_number }}
        path: reports/analysis/
        retention-days: 30

    # TODO #10: Implement artifact upload for raw test data
    #
    # Upload individual run results:
    # - path: reports/runs/
    # - retention-days: 7 (shorter, these are large)
    # - Useful for deep debugging
    - name: ðŸ“¤ Upload test runs data
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-runs-${{ github.run_number }}
        path: reports/runs/
        retention-days: 7

    # TODO #11: Implement PR comment functionality
    #
    # Purpose: Post results as PR comment
    # Action: actions/github-script@v7
    #
    # Conditions:
    # - Only run for pull_request events
    # - Use if: github.event_name == 'pull_request' && always()
    #
    # Script logic:
    # 1. Read markdown report from filesystem
    # 2. Extract executive summary section
    # 3. Check for existing bot comment
    # 4. Update existing or create new comment
    #
    # GitHub API methods:
    # - github.rest.issues.listComments()
    # - github.rest.issues.updateComment()
    # - github.rest.issues.createComment()
    #
    # Context variables:
    # - context.repo.owner: Repository owner
    # - context.repo.repo: Repository name
    # - context.issue.number: PR number
    - name: ðŸ’¬ Comment on PR
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');

          // Read the markdown report
          let comment = '## ðŸ” Flaky Test Detection Results\n\n';

          if (fs.existsSync('reports/analysis/flaky-report.md')) {
            const report = fs.readFileSync('reports/analysis/flaky-report.md', 'utf8');

            // Extract key sections for PR comment
            const lines = report.split('\n');
            let inSummary = false;
            let summaryContent = [];

            for (const line of lines) {
              if (line.includes('Executive Summary')) {
                inSummary = true;
              } else if (inSummary && line.startsWith('##')) {
                break;
              } else if (inSummary) {
                summaryContent.push(line);
              }
            }

            comment += summaryContent.join('\n');
            comment += '\n\n[View Full Report](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})';
          } else {
            comment += 'âŒ No report generated. Check the workflow logs for errors.';
          }

          // Find existing comment or create new one
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const botComment = comments.find(comment =>
            comment.user.type === 'Bot' &&
            comment.body.includes('Flaky Test Detection Results')
          );

          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: comment
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          }

    # TODO #12: Implement check run creation
    #
    # Purpose: Create visual status check on PR
    # Action: actions/github-script@v7
    #
    # Check run details:
    # - name: 'Flaky Test Detection'
    # - conclusion: 'success' or 'failure' based on flaky_count
    # - Include summary with metrics
    #
    # API method: github.rest.checks.create()
    #
    # This creates the âœ“ or âœ— mark on the PR
    - name: ðŸ“ˆ Create check run
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const flaky_count = ${{ steps.parse.outputs.flaky_count || 0 }};
          const total_count = ${{ steps.parse.outputs.total_count || 0 }};
          const health_score = ${{ steps.parse.outputs.health_score || 0 }};
          const status_emoji = '${{ steps.parse.outputs.status_emoji || "â“" }}';

          const conclusion = flaky_count === 0 ? 'success' : 'failure';
          const title = `${status_emoji} Flaky Test Detection: ${flaky_count} flaky tests found`;
          const summary = `
          ### Test Suite Health Score: ${health_score}/100

          - **Total Tests**: ${total_count}
          - **Flaky Tests**: ${flaky_count}
          - **Detection Runs**: ${{ github.event.inputs.runs || '10' }}

          ${flaky_count > 0 ? 'âš ï¸ Flaky tests detected. Please review the detailed report.' : 'âœ… No flaky tests detected!'}
          `;

          await github.rest.checks.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            name: 'Flaky Test Detection',
            head_sha: context.sha,
            status: 'completed',
            conclusion: conclusion,
            output: {
              title: title,
              summary: summary
            }
          });

    # TODO #13: Implement Slack notification (optional)
    #
    # Purpose: Alert team when flaky tests are detected
    # Only sends notification when:
    # - The detection job fails (has flaky tests)
    # - AND flaky_count > 0
    #
    # Requires: SLACK_WEBHOOK_URL secret to be configured
    - name: ðŸ“¢ Send Slack notification
      if: failure() && steps.parse.outputs.flaky_count > 0
      uses: slackapi/slack-github-action@v1
      with:
        payload: |
          {
            "text": "${{ steps.parse.outputs.status_emoji }} Flaky Test Detection Alert",
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "ðŸ”´ Flaky Tests Detected"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Repository:*\n${{ github.repository }}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Branch:*\n${{ github.ref_name }}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Flaky Tests:*\n${{ steps.parse.outputs.flaky_count }} / ${{ steps.parse.outputs.total_count }}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Health Score:*\n${{ steps.parse.outputs.health_score }}/100"
                  }
                ]
              },
              {
                "type": "actions",
                "elements": [
                  {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "View Report"
                    },
                    "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                ]
              }
            ]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

# ============================================
# Workflow Variables Reference
# ============================================
#
# GitHub provides these variables:
# - github.event_name: Type of event (push, pull_request, etc.)
# - github.event.inputs: Manual trigger inputs
# - github.run_number: Unique number for each workflow run
# - github.run_id: Unique ID for workflow run
# - github.repository: owner/repo format
# - github.sha: Commit SHA that triggered workflow
# - context.repo: Repository information object
# - context.issue: PR/issue information
#
# ============================================
# Best Practices
# ============================================
#
# 1. Always use 'if: always()' for cleanup/reporting steps
# 2. Use 'continue-on-error: true' when you need to process results
# 3. Set appropriate retention periods for artifacts
# 4. Use structured output with echo "key=value" >> $GITHUB_OUTPUT
# 5. Cache dependencies when possible
# 6. Use specific action versions (@v4) not @latest
# 7. Add meaningful step names with emojis for clarity
#
# ============================================
# Testing Your Workflow
# ============================================
#
# 1. Local testing with act:
#    brew install act
#    act -j detect-flaky-tests
#
# 2. Test triggers:
#    - Push to feature branch and create PR
#    - Manually trigger from Actions tab
#    - Wait for scheduled run
#
# 3. Debugging:
#    - Check workflow logs in Actions tab
#    - Download artifacts for inspection
#    - Add debug echo statements
#    - Use actions/github-script for API exploration
#
# ============================================
# Common Issues and Solutions
# ============================================
#
# 1. "jq: command not found"
#    Solution: jq is pre-installed on GitHub runners
#
# 2. "Permission denied" on PR comment
#    Solution: Check GITHUB_TOKEN permissions
#
# 3. Artifacts not uploading
#    Solution: Ensure paths exist and contain files
#
# 4. Workflow not triggering
#    Solution: Check branch names and path filters
#
# 5. Check run not appearing
#    Solution: Verify head_sha is correct commit