# GitHub Actions Workflow for Flaky Test Detection
# 
# This workflow automatically runs flaky detection on:
# - Nightly schedule
# - Pull requests  
# - Manual trigger
#
# Learning Goals:
# - Understand CI/CD pipelines
# - Learn GitHub Actions syntax
# - Practice automation strategies
# - Implement PR feedback mechanisms

name: Flaky Test Detection with CTRF

# TODO #1: Define workflow triggers
# 
# The 'on' section defines when this workflow runs.
# You need to implement three triggers:
#
# 1. schedule:
#    - Use cron syntax: '0 2 * * *' (2 AM daily)
#    - Format: minute hour day month day-of-week
#    - Tools like crontab.guru help build cron expressions
#
# 2. workflow_dispatch:
#    - Allows manual triggering from GitHub UI
#    - Add 'inputs' with a 'runs' parameter
#    - Type: choice with options 5, 10, 15, 20, 30
#    - Default: '10'
#
# 3. pull_request:
#    - Trigger on PRs to main/develop branches
#    - Only when test files change (use 'paths' filter)
#    - Watch: src/tests/**, playwright.config.ts, package.json
on:
  # TODO: Implement the three triggers here
  # Hint: Each trigger is a top-level key under 'on'

jobs:
  # TODO #2: Define the main job
  # 
  # Job name: detect-flaky-tests
  # Runner: ubuntu-latest (GitHub-hosted Linux runner)
  # Timeout: 60 minutes (tests can take time)
  detect-flaky-tests:
    # TODO: Add runs-on and timeout-minutes

    steps:
    # TODO #3: Implement checkout step
    # 
    # Purpose: Clone the repository code
    # Action: actions/checkout@v4
    # 
    # Why v4? Latest stable version with improved performance
    # Name: Use emoji ðŸ“¥ for visual clarity

    # TODO #4: Implement Node.js setup
    # 
    # Purpose: Install Node.js and npm
    # Action: actions/setup-node@v4
    # 
    # Configuration:
    # - node-version: '20' (LTS version)
    # - cache: 'npm' (speeds up dependency installation)
    #
    # The cache option reuses node_modules between runs

    # TODO #5: Implement dependency installation
    # 
    # Purpose: Install npm packages and Playwright browsers
    # 
    # Commands to run:
    # 1. npm ci (faster than npm install for CI)
    # 2. npx playwright install --with-deps chromium
    #
    # Why npm ci?
    # - Installs from package-lock.json
    # - Faster and more reliable for CI
    # - Fails if lock file is outdated

    # TODO #6: Implement flaky detection execution
    # 
    # Purpose: Run the main detection script
    # 
    # Key points:
    # - id: detection (allows referencing in other steps)
    # - continue-on-error: true (process results even if tests fail)
    # - Use github.event.inputs.runs for manual trigger
    # - Default to '10' if not manually triggered
    #
    # Command: npm run detect-flaky -- <number_of_runs>
    #
    # The ${{ }} syntax is GitHub Actions expression syntax

    # TODO #7: Implement results parsing
    # 
    # Purpose: Extract metrics from JSON report
    # 
    # Implementation details:
    # - if: always() (run even if previous steps failed)
    # - id: parse (for referencing outputs)
    # - Use jq tool to parse JSON (pre-installed on runners)
    # - Set outputs using >> $GITHUB_OUTPUT
    #
    # Outputs to set:
    # - flaky_count: Number of flaky tests
    # - total_count: Total number of tests
    # - health_score: Overall health score
    # - status_emoji: âœ… or ðŸ”´ based on results
    #
    # Example jq usage:
    # jq '.summary.flakyTests' reports/analysis/flaky-report.json

    # TODO #8: Implement artifact upload for CTRF reports
    # 
    # Purpose: Save CTRF JSON reports for debugging
    # Action: actions/upload-artifact@v4
    # 
    # Configuration:
    # - name: ctrf-reports-${{ github.run_number }}
    # - path: reports/ctrf/
    # - retention-days: 30
    #
    # Why upload artifacts?
    # - Debug test failures
    # - Historical analysis
    # - Share results with team

    # TODO #9: Implement artifact upload for analysis reports
    # 
    # Similar to #8 but for:
    # - path: reports/analysis/
    # - Contains HTML, MD, JSON, CSV reports
    # - These are the main output files

    # TODO #10: Implement artifact upload for raw test data
    # 
    # Upload individual run results:
    # - path: reports/runs/
    # - retention-days: 7 (shorter, these are large)
    # - Useful for deep debugging

    # TODO #11: Implement PR comment functionality
    # 
    # Purpose: Post results as PR comment
    # Action: actions/github-script@v7
    # 
    # Conditions:
    # - Only run for pull_request events
    # - Use if: github.event_name == 'pull_request' && always()
    #
    # Script logic:
    # 1. Read markdown report from filesystem
    # 2. Extract executive summary section
    # 3. Check for existing bot comment
    # 4. Update existing or create new comment
    #
    # GitHub API methods:
    # - github.rest.issues.listComments()
    # - github.rest.issues.updateComment()
    # - github.rest.issues.createComment()
    #
    # Context variables:
    # - context.repo.owner: Repository owner
    # - context.repo.repo: Repository name
    # - context.issue.number: PR number

    # TODO #12: Implement check run creation
    # 
    # Purpose: Create visual status check on PR
    # Action: actions/github-script@v7
    # 
    # Check run details:
    # - name: 'Flaky Test Detection'
    # - conclusion: 'success' or 'failure' based on flaky_count
    # - Include summary with metrics
    #
    # API method: github.rest.checks.create()
    #
    # This creates the âœ“ or âœ— mark on the PR

# ============================================
# Workflow Variables Reference
# ============================================
#
# GitHub provides these variables:
# - github.event_name: Type of event (push, pull_request, etc.)
# - github.event.inputs: Manual trigger inputs
# - github.run_number: Unique number for each workflow run
# - github.run_id: Unique ID for workflow run
# - github.repository: owner/repo format
# - github.sha: Commit SHA that triggered workflow
# - context.repo: Repository information object
# - context.issue: PR/issue information
#
# ============================================
# Best Practices
# ============================================
#
# 1. Always use 'if: always()' for cleanup/reporting steps
# 2. Use 'continue-on-error: true' when you need to process results
# 3. Set appropriate retention periods for artifacts
# 4. Use structured output with echo "key=value" >> $GITHUB_OUTPUT
# 5. Cache dependencies when possible
# 6. Use specific action versions (@v4) not @latest
# 7. Add meaningful step names with emojis for clarity
#
# ============================================
# Testing Your Workflow
# ============================================
#
# 1. Local testing with act:
#    brew install act
#    act -j detect-flaky-tests
#
# 2. Test triggers:
#    - Push to feature branch and create PR
#    - Manually trigger from Actions tab
#    - Wait for scheduled run
#
# 3. Debugging:
#    - Check workflow logs in Actions tab
#    - Download artifacts for inspection
#    - Add debug echo statements
#    - Use actions/github-script for API exploration
#
# ============================================
# Common Issues and Solutions
# ============================================
#
# 1. "jq: command not found"
#    Solution: jq is pre-installed on GitHub runners
#
# 2. "Permission denied" on PR comment
#    Solution: Check GITHUB_TOKEN permissions
#
# 3. Artifacts not uploading
#    Solution: Ensure paths exist and contain files
#
# 4. Workflow not triggering
#    Solution: Check branch names and path filters
#
# 5. Check run not appearing
#    Solution: Verify head_sha is correct commit